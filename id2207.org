#+TITLE: ID2207
#+AUTHOR: Steven Shidi Zhou
#+DESCRIPTION: Lecture notes on Course ID2207 Modern Methods in Software Development
* TODO Lecture 1 - Software Life Cycle
** Software nature
+ intangible. It is difficult to understand development efforts
+ untrained people can hack something together
+ easily reproducible. Cost is not in manufacturing but in development
+ labor intensive. hard to automate
+ easy to modify
+ a logical rahter than physical product. It does not wear out with use.
** Software Engineering Definition
Software Engineering is a collection of techniques, methodologies and tools that help with the production of:
+ a high quality software system
+ with a given budget
+ before a given deadline
+ while change occurs.

Software Engineering is a *Modeling activity*
Software Engineering is a *problem-solving activity*
Software Engineering is a *knowledge acquisition activity*

** Dealing with Complexity
** Software development concepts and activities
*** Abstractions
Ignore non-essential details - Modeling
**** System Model
***** Functional Model
What are the functions of the system? How is data flowing through the system?
***** Object Model
What is the struction of the system? What are the objects and how are they related?
***** Dynamic Model:
How does the system react to external events? How is the event flow in the system?
**** Task Model
+ What are the dependencies between the tasks?
+ How can this be done within the time limit?
+ What are the roles in the project or organization?
**** Issues Model
+ What are the open and closed issues?
+ What constraints were posed by the client?
+ What resolutions were made?
*** Decomposition
Break probelm into sub-problems
**** Functional decomposition
*Emphasizes the ordering of operations*
+ The system is decomposed into functional modules
+ Each module is a processing step (function) in the application domain
+ Modules can be decomposed into smaller modules
**** Object oriented decomposition
*Emphasizes the agents that cause the operations*
+ The system is decomposed into classes("objects")
+ Each class is a major abstraction in the application domain
+ Classes can be decomposed into smaller classes
*** Hierarchy
Simple Relationship between chunks. Relationship between components obrained from abstraction and decomposition.
**** Part of hierarchy
**** Is kind of hierarchy

** Software development lifecycle
*** Simplified view
+ Analysis - What is the program
+ System Design - What is the solution
+ Object Design - What is the solution in the context of an existing hardware system?
+ Implementation - How is the solution constructed?
*** Analysis
Consentrates on system requirements - definition of a system from user's point of view
**** Requirements elicitation
Determining functionality user needs and a way of its delivering.
**** Requirements analysis
Formalizing determined requirements and ensuring their completeness and consistnecy
*** Design
Constructing the system
**** System design
Defining a system architecture in terms of design goals and a subsystem decomposition.
**** Object design
Modeling and construction activities related to the solution domain
*** Implementation
translation of the solution domain model into code.
*** Testing
The goal is to discover faults in the system to be repaired before the system delivery.

** Models
*** Waterfall
+ Clear milestones
+ No need to look back (linear system), one activity at a time
+ Easy to check progress: e.g. 90% coded, 20% tested
+ However, software development is not sequential, meaning that the development stages overlap
+ Different stakeholders need different abstractions
+ System development is a nonlinear activity

V-model is a slight imporved version with Testing correspond back to the stages
*** Incremental
Divide into different small stages, but in each stage we can still doing Waterfall.
*** Spiral/UP(iterative)
Software development is iterative: 
+ During design probelms requirements are identified
+ During coding, design and requirements problems are found
+ During testing, coding, design, & requirement errors are found

**** Spiral Model
Spiral model is an iterative model with the following activities:
+ Determine objectives and constraints
+ Evaluate Alternatives
+ Identifying risks
+ Resolve risks by assigning priorities to risks
+ Develop a series of prototypes for the identified risks starting with the highest risk.
+ Use a waterfall model for each prototype development "cycle"
+ If a risk has successfully been resolved, evaluate the results of the "cycle" and plan for the next round
+ If a certain risk can not be resolved, terminate the project immediately

**** Limitation of Water fall and Spiral Models
Neither of these models deals well with frequent changes:
+ The waterfall model assume that once you are done with a phase, all issues covered in that phase are closed and cannot be reopened
+ The Spiral model can deal with change between phases, but once inside a phase, no change is allowed

**** Unified Software Development Process (UP)
Repeats over a series of cycles. Each cycle consist of four phases which are subdivided into iterations:
+ *Inception*: establishes a business case for the system.
+ *Elaboration*:  most of the product cases are specified in details, architecture is designed.
+ *Construction*: the product is built. The architectural baseline becomes a full-pledged system.
+ *Transition*: priod when product moves to beta release.
*** Formal methods
+ *Indictive methods*: where a program is built on the basis of input-output pairs or Examples of Computations
+ *Deductive methods*: which uses automatic deduction of a proof of solvability of a problem and derives a program from the proof
+ *Transformational methods*: where a program is derived stepwise from a Specification by means of transformations.
*** Agile methods
+ Individuals and interactions over processes and tools
+ Working software over comprehensive documentation
+ Customer collaboration over contract negotiation
+ Responding to change over following a plan

* TODO Lecture 2 -
* TODO Lecture 3 -
* TODO Lecture 4 -
* TODO Lecture 5 -
* TODO Lecture 6 -
* TODO Lecture 7 -
* TODO Lecture 8 -
* TODO Lecture 9 -
* TODO Lecture 10 -

* DONE Quiz 1
** Question 1
*Software Engineering*: The application of Engineering principle to deliver and maintain high quality & reliable software on time and within budget
*System Models*: Abstract representations of the system that enable us to understand and visualize the system. They are useful for too large, too small, too complicated, or too expensive systems as they focus on the relevant details and ignore everything else.
*Abstractions, decomposition and hierarchy*: Approaches to deal with software complexity
*Complexity and change*: Major factors of the software design process. 
*Problem solving in software engineering*: An activity that requires experimentation and reuse of pattern solutions in order to incrementally develop a system that matches the client's needs
** Question 2
*Risk based development*: A Software process that focus on the identification of high risk components to avoid suprises late in the project
*Rational activity in software engineering*: Understanding the context in which design decisions are taken in a software development process.
*Requirement Elicitation*: The activity in which the purpose and functionality of the system is defined. The results of this activity use case diagrams.
*Requirement Analysis*: The activity in which the developer tries to produce a model of the system that os correct, complete, consistent and unambiguous.
*System Design*: The activity in which the design goals and architecture of the project are defined, and the system is composed into smaller subsystems.
** Question 3 - UML
*Use case diagrams*: Diagrams used tp represent the functionality of the system during requirements elicitation and analysis activities. They show a behaviour of the system from the user's point of view.
*Class diagrams*: Diagrams used to represent the structure of the system in terms of objects, classes, attributes, operations and their associations. They are used in three different activities: during requirements analysis to model problem domain concepts, during system design to model interfaces and subsystems, and during object design to model classes.
*Interaction diagrams*: Diagrams used to represent the dynamic behaviour of the system and to visualizethe communication between the objects. Sequence and communication diagrams are special forms of this category.
*Sequence diagrams*:  Diagrams used during requirements analysis to refine use case descriptions. They also help in identifyinf additional participating objects. They are also used during system design to refine subsystem interfaces.
*State machine diagrams*: Diagrams used to describe the dynamic behaviour of an individual object as a number of states and transitions. Each state represents a set of values for an object. A transition represents the future state that the object can move to, with the conditions associatied with the change of the state.
*Activity diagrams*: Diagrams that show control and data flows within a system. They describe the begavior of the system in terms of activities. They model elelments that represent the execution of a group of operations. An activity's execution can be triggered by the completion of other activities, by the availability of certain objects, or by external events.
** Question 4 - Relationship
*An actor*: An entity that interacts with the sustem and represents a certain role or group of roles. It can be either a user, another system or a physical environment. It has a name and an optional description. 
*Boundary*: It can be identified by distinguishing the tasks accomplished by the system and the tasks accomplished by its environment.
*Extend Relationship*: A Relationship that represents an exceptional invoked case.
*Include Relationship*: A Relationship that represents behaviour that is factored out of the use case to be reused by other use cases.
*Aggregation Relationship*: A special case pf association Relationship denoting a consists of hierarchy. A special form of this Relationship is the composition Relationship where components cannot exists without the aggregate.
*Qualifiers*: They can be used to redice the multiplicity of an association. 

* TODO Quiz 2 - 
* TODO Quiz 3 - 
* TODO Quiz 4 - 
