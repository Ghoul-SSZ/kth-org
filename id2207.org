#+TITLE: ID2207
#+AUTHOR: Steven Shidi Zhou
#+DESCRIPTION: Lecture notes on Course ID2207 Modern Methods in Software Development
* DONE Lecture 1 - Software Life Cycle
** Software nature
+ intangible. It is difficult to understand development efforts
+ untrained people can hack something together
+ easily reproducible. Cost is not in manufacturing but in development
+ labor intensive. hard to automate
+ easy to modify
+ a logical rahter than physical product. It does not wear out with use.
** Software Engineering Definition
Software Engineering is a collection of techniques, methodologies and tools that help with the production of:
+ a high quality software system
+ with a given budget
+ before a given deadline
+ while change occurs.

Software Engineering is a *Modeling activity*
Software Engineering is a *problem-solving activity*
Software Engineering is a *knowledge acquisition activity*

** Dealing with Complexity
** Software development concepts and activities
*** Abstractions
Ignore non-essential details - Modeling
**** System Model
***** Functional Model
What are the functions of the system? How is data flowing through the system?
***** Object Model
What is the struction of the system? What are the objects and how are they related?
***** Dynamic Model:
How does the system react to external events? How is the event flow in the system?
**** Task Model
+ What are the dependencies between the tasks?
+ How can this be done within the time limit?
+ What are the roles in the project or organization?
**** Issues Model
+ What are the open and closed issues?
+ What constraints were posed by the client?
+ What resolutions were made?
*** Decomposition
Break probelm into sub-problems
**** Functional decomposition
*Emphasizes the ordering of operations*
+ The system is decomposed into functional modules
+ Each module is a processing step (function) in the application domain
+ Modules can be decomposed into smaller modules
**** Object oriented decomposition
*Emphasizes the agents that cause the operations*
+ The system is decomposed into classes("objects")
+ Each class is a major abstraction in the application domain
+ Classes can be decomposed into smaller classes
*** Hierarchy
Simple Relationship between chunks. Relationship between components obrained from abstraction and decomposition.
**** Part of hierarchy
**** Is kind of hierarchy

** Software development lifecycle
*** Simplified view
+ Analysis - What is the program
+ System Design - What is the solution
+ Object Design - What is the solution in the context of an existing hardware system?
+ Implementation - How is the solution constructed?
*** Analysis
Consentrates on system requirements - definition of a system from user's point of view
**** Requirements elicitation
Determining functionality user needs and a way of its delivering.
**** Requirements analysis
Formalizing determined requirements and ensuring their completeness and consistnecy
*** Design
Constructing the system
**** System design
Defining a system architecture in terms of design goals and a subsystem decomposition.
**** Object design
Modeling and construction activities related to the solution domain
*** Implementation
translation of the solution domain model into code.
*** Testing
The goal is to discover faults in the system to be repaired before the system delivery.

** Models
*** Waterfall
+ Clear milestones
+ No need to look back (linear system), one activity at a time
+ Easy to check progress: e.g. 90% coded, 20% tested
+ However, software development is not sequential, meaning that the development stages overlap
+ Different stakeholders need different abstractions
+ System development is a nonlinear activity

V-model is a slight imporved version with Testing correspond back to the stages
*** Incremental
Divide into different small stages, but in each stage we can still doing Waterfall.
*** Spiral/UP(iterative)
Software development is iterative: 
+ During design probelms requirements are identified
+ During coding, design and requirements problems are found
+ During testing, coding, design, & requirement errors are found

**** Spiral Model
Spiral model is an iterative model with the following activities:
+ Determine objectives and constraints
+ Evaluate Alternatives
+ Identifying risks
+ Resolve risks by assigning priorities to risks
+ Develop a series of prototypes for the identified risks starting with the highest risk.
+ Use a waterfall model for each prototype development "cycle"
+ If a risk has successfully been resolved, evaluate the results of the "cycle" and plan for the next round
+ If a certain risk can not be resolved, terminate the project immediately

**** Limitation of Water fall and Spiral Models
Neither of these models deals well with frequent changes:
+ The waterfall model assume that once you are done with a phase, all issues covered in that phase are closed and cannot be reopened
+ The Spiral model can deal with change between phases, but once inside a phase, no change is allowed

**** Unified Software Development Process (UP)
Repeats over a series of cycles. Each cycle consist of four phases which are subdivided into iterations:
+ *Inception*: establishes a business case for the system.
+ *Elaboration*:  most of the product cases are specified in details, architecture is designed.
+ *Construction*: the product is built. The architectural baseline becomes a full-pledged system.
+ *Transition*: priod when product moves to beta release.
*** Formal methods
+ *Indictive methods*: where a program is built on the basis of input-output pairs or Examples of Computations
+ *Deductive methods*: which uses automatic deduction of a proof of solvability of a problem and derives a program from the proof
+ *Transformational methods*: where a program is derived stepwise from a Specification by means of transformations.
*** Agile methods
+ Individuals and interactions over processes and tools
+ Working software over comprehensive documentation
+ Customer collaboration over contract negotiation
+ Responding to change over following a plan

* TODO Lecture 2 - UML & OOP
functional requirements
nonfunctional requirements
* TODO Lecture 3 -
* TODO Lecture 4 -
* TODO Lecture 5 -
* TODO Lecture 6 -
* TODO Lecture 7 -
* TODO Lecture 8 -
* DONE Lecture 9 - Agile
** Limitation of waterfall and spiral models
Neither of these models deals well with frequent changes:
+ *Waterfall Model* assume that once you are done with a phase, all issues covered in that phase are closed and can not be reopened
+ *Spiral Model* can deal with changes between phases, but once inside a phase, no change is allowed.
** Practices of XP
+ Short releases (Short cycles)
+ Pair programming
+ Test-Driven development (testing)
+ Collective Ownership
+ Continuous integration
+ The planning game
+ Simple design
+ Refactoring
+ Metaphor
+ sustainable pace, codeing standards and on site Customer
** Some definitoins
+ *Spike*: Quick throw away explorations into the nature of a potential solution.
+ *Metaohor*: a story that everyone can tell about how the systme works. It may change over time as you learn more about the system, and as you get inspired in your understanding of it.
** Limitations of XP
+ XP only works well with small teams , 6 or 7 is probably a reasonable limit, althrough it may work with up to 12.
+ XP only works with the very best software engineers. A typical team will mostly hold PHD in computing or have equivalent industrial experience.
+ XP is extermely demanding and requires very effective teamwork. Not every engineer can cope with the approach.
** Summary
+ No explicit analysis /design models
    + Agile programming goal: Minimize the amount of documentation produced beside the code.
    + The assumption is that smaller deliverables reduce the amount of work and duplication of issues.
+ Models are only communicated among participants
    + The client is seen as a *Walking specification*
+ Source Code is the only external model
    + The system design is made visible in the source code by using explicit names and by decomposing methods into many simpler ones. (each with a descriptive name)
    + Refactoring is used to improve the source code
    + Coding Standards are used to help developers communicate using only the source code
* DONE Lecture 10 - Testing
** What is tesitng? 
+ Testing is the process of analysing a systme or components to detect the differences between specified (required) and observed (existing) bahavior.
+ Systematic way to find faults in a planned way in the implemneted software.
+ Done best by independent testers
** Overview
+ *Reliability*: The measure of success with which the observed behavior of a system confirms to some specification of its behavior.
+ *Fault(Bug)*: The mechanical or algorithmic cause of an error. (A design or coding mistake that may cause abnormal component behavior)
+ *Error*: Manifestation of the fault during the execution of the system. The system is in a state such that further processing by the system can lead to a failure
+ *Failure*: Any deviation of the observed behavior from the specified behavior.
+ *Test case*: A set of inputs and expected results that exercises a component with the purpose of causing failures and detecting faults.
+ *Test stub*: A partial implementation of components on which the tested component depends
+ *Test driver*: A partial implementation of a component that depends on the tested component
** Unit testing
*** Unit testing elements.
+ Static analysis:
    + Hand execution: reading the source code
    + Automated Tool checking for:
        + Syntactic and semantic errors
        + Deåartire from coding standards
+ Dynamic Analysis
    + Black box testing (testing the input/output behaviour)  e.g. assert equal, or within a range
    + White box testing (Test the internal logic of the subsystem or object)
*** White box testing
+ Focus: Thoroughness (Coverage). Every statement in the component is executed at least once.
+ Statement Testing (Algebraic Testing):  Test single statements 
+ Branch Testing  (Conditional Testing): Make sure that each possible outcome from a condition is tested at least once
** System Testing
**** Functional testing
+ Finds differences between the functional requirements and the system
+ BlackBox technique
+ Test cases are derived from use case model
+ Selects tests that are relevant to the user and have high probability of a failure
**** Performance testing
+ Stress testing
+ Volume testing
+ Security testing
+ Timing testing
+ Recovery tests
**** Acceptance testing
+ Benchmark test
+ Competitor testing
+ Shadow testing
**** Pilot testing (field test)
+ The system is installed and usedby aselected set of users
+ Pilot tests are usefulwhen a system isbuilt without a specific set of requirements or without a specific customer in mind
+ An alpha test is a pilot test with users exercising the system in the development environment
+ In a beta test, the acceptance test is performed by a limited number of end usersin the targetenvironment
**** Installation testing
+ Testing reconfiguration
+ Often repeats test cases from previous phases
+ Some requirements cannot be executedin thedevelopment environment because they require target-specific resources
* DONE Quiz 1
** Question 1
+ *Software Engineering*: The application of Engineering principle to deliver and maintain high quality & reliable software on time and within budget
+ *System Models*: Abstract representations of the system that enable us to understand and visualize the system. They are useful for too large, too small, too complicated, or too expensive systems as they focus on the relevant details and ignore everything else.
+ *Abstractions, decomposition and hierarchy*: Approaches to deal with software complexity
+ *Complexity and change*: Major factors of the software design process. 
+ *Problem solving in software engineering*: An activity that requires experimentation and reuse of pattern solutions in order to incrementally develop a system that matches the client's needs
** Question 2
+ *Risk based development*: A Software process that focus on the identification of high risk components to avoid suprises late in the project
+ *Rational activity in software engineering*: Understanding the context in which design decisions are taken in a software development process.
+ *Requirement Elicitation*: The activity in which the purpose and functionality of the system is defined. The results of this activity use case diagrams.
+ *Requirement Analysis*: The activity in which the developer tries to produce a model of the system that os correct, complete, consistent and unambiguous.
+ *System Design*: The activity in which the design goals and architecture of the project are defined, and the system is composed into smaller subsystems.
** Question 3 - UML
+ *Use case diagrams*: Diagrams used to represent the functionality of the system during requirements elicitation and analysis activities. They show a behaviour of the system from the user's point of view.
+ *Class diagrams*: Diagrams used to represent the structure of the system in terms of objects, classes, attributes, operations and their associations. They are used in three different activities: during requirements analysis to model problem domain concepts, during system design to model interfaces and subsystems, and during object design to model classes.
+ *Interaction diagrams*: Diagrams used to represent the dynamic behaviour of the system and to visualizethe communication between the objects. Sequence and communication diagrams are special forms of this category.
+ *Sequence diagrams*:  Diagrams used during requirements analysis to refine use case descriptions. They also help in identifyinf additional participating objects. They are also used during system design to refine subsystem interfaces.
+ *State machine diagrams*: Diagrams used to describe the dynamic behaviour of an individual object as a number of states and transitions. Each state represents a set of values for an object. A transition represents the future state that the object can move to, with the conditions associatied with the change of the state.
+ *Activity diagrams*: Diagrams that show control and data flows within a system. They describe the begavior of the system in terms of activities. They model elelments that represent the execution of a group of operations. An activity's execution can be triggered by the completion of other activities, by the availability of certain objects, or by external events.
** Question 4 - Relationship
+ *An actor*: An entity that interacts with the sustem and represents a certain role or group of roles. It can be either a user, another system or a physical environment. It has a name and an optional description. 
+ *Boundary*: It can be identified by distinguishing the tasks accomplished by the system and the tasks accomplished by its environment.
+ *Extend Relationship*: A Relationship that represents an exceptional invoked case.
+ *Include Relationship*: A Relationship that represents behaviour that is factored out of the use case to be reused by other use cases.
+ *Aggregation Relationship*: A special case pf association Relationship denoting a consists of hierarchy. A special form of this Relationship is the composition Relationship where components cannot exists without the aggregate.
+ *Qualifiers*: They can be used to redice the multiplicity of an association. 

* DONE Quiz 2
** Question 2
+ *Robustness*: The degree to which a system can function in a correct way, even with invalid inputs or stressful environment conditions.
+ *Reliability*: The ability of a system to perform its required functions under stated conditions for a specified period of time. For Examples, the ability to detect specified faults or to withstand specidied security attacks.
+ *Usability*: The ease with which the user can learn how to operate, prepare inputs for, and interpret outputs of a system.
+ *Supportability*: Ease of changes to the system after deployment
+ *Performance*: Quantifiable attributes of the system such as response time, througput, availability and accuracy.
** Question 4
+ *Consistency*: There are no contradictions between requirements
+ *Unambiguity*: There is only one way to interpret certain requirement
+ *Verifiability*: Repeatable test can be executed to demonstrate that the system fulfills the requirements Specification
+ *Realism*: The system can be implemented within the defined constraints
** Question 6
+ *Prototyping*: It is widely used when projects are complex and/or innovative
+ *BrainStorming*: An activity where people propose ideas and solutions to a probelm, putting aside all that can obstacle the consensus.
+ *Joint Application Design*: A BrainStorming like technique where all stakeholders meet, discuss and come to mutually acceptable solution.
+ *Rapid Application Development*: a technique suitable for fast software development, but usually limited to a small project.
+ *Questionnaire*: Method for requirements elicitation that does not require the physical presense of the requirements analyst.
+ *Observation*: A method used when the user cannot convey sufficient information when being interviewed. It should be carried out for a prolonged time.

* DONE Quiz 3 
** Question 1
+ *Entity Object*: Objects that present persistent information tracked by the system. To identify them from use cases, we usually search for recurring nouns, data sources, real-world activities that we need to track
+ *Boundary Object*: Objects that represent the system interface and the interactions between the system and the users. To identify them, we usually identify the forms that users use to interact with the system, along with other forms of interaction, such as notices or messages from the system.
+ *Control Object*: Objects that describe the order in which interactions between the user and the system occur.
** Question 3
+ *Falsification principle*: Demonstrating that relevant details of the system are not presented or presented incorrectly.
+ *Syntactic Approach*: One of the class identification approaches in which a noun-verb analysis is used to identify components of the object model.
+ *Organization Class*: In common class pattern approach, this type of classes represent any kind of purposeful grouping or collection of things
+ *CRC*: An approach that involves brainstorming sessions, where the team members exchange cards on which possible classes are identified, with their responsibilities and collaborators
+ *Fork Diagram*: A type of sequence diagrams in which the dynamic behavior is centralized in a single object (the control object) that knows all the other objects and uses them for direct commands
+ *Stair Diagram*: A type of sequence diagram in which the dynamic behavior is distributed. Each object delegates some responsibility to other objects

* DONE Quiz 4
** Question 1 - System Design
+ *Design goals*: The qualities of the system that the developer should optimize. The are derived from the non-functional requirements.
+ *Software architecture*: The subsystem decomposition in terms of subsystem responsibilities, dependencies among subsystems, subsystem mapping to hardware, and major policy decisions such as control flow, access control, and data storage.
+ *Boundary use cases*: Description of the system configuration, startup, shutdown, and exception handling issues.
+ *Services*: A set of related operations that share a common purpose. The are used to manage the interaction between subsystems.
+ *Coupling*: It is used to measure the dependencies between subsystems. In ideals subsystem decomposition, it should be minimized.
+ *Cohesion*: It measures the dependencies among the classes within a subsystem. In ideal subsystem decomposition, it should be maximized 
+ *Layering*: A technique that allows the system to be organized as a hierarchy of subsystems, each providing higher level services to the subsystem above it using lower-level services from the systems below it.
+ *Partitioning*: A technique that organizes the subsystem as peers that mutually provide different services to each other
** Question 2 - Architectural Styles
+ *Repository*: In this architectural style, subsystems access and modify a single data structure. Subsystems are independent and interact only through this central component. Usually used for the database management systems.
+ *MVC*: In this architectural style, subsystem are classified into 3 different types: one that maintain the demain knowledge, another one related to the user interface and the last one manages the sequence of interactions with the user.
+ *Client-Server*: In this architectural style, one subsystem provides services to instances for the other subsystem which are responsible for interacting with the user.
+ *Peer-to-Peer*: Ageneralization of the client/server architectural style which subsystem can act both as a server and client in the sense that each subsystem can request and provide services.
+ *Pipe and filter*: A style in which subsystems process data received from a set of inputs and send results to other subsystems via a set of outputs. They are suitable for systems that apply transformations to streams of data without intervention by users.

* Flash cards
+ *What is UML?*:	"A modeling language that is intended to provide a standard way to visualize the design of a system"
+ *Describe the functional model*:	"A model that describes the functionality of the system from the user's point of view"
+ *How is the functional model in system development represented in UML?*:	"With use case diagrams"
+ *"Describe the object model"*:	"A model that describes the structure of the system in terms of objects, attributes, associations and operations"
+ *"How is the object model represented in UML?"*:  "With class diagrams"
+ *"Describe the dynamic model"*:	"A model that describes the internal behavior of the system"
+ *"How is the dynamic model represented in UML?"*: "With interaction diagrams, state machine diagrams and activity diagrams"
+ *"What is a Use Case?"*	"A use case describes a function provided by the system that yields a visible result for an actor"
+ *"What is a Use Case Diagram?"*:	"A representation of the functionality of the system and its environment."
+ *"When are Use Case Diagrams used?"*:	"During requirements elicitation and analysis"
+ *"Describe the extends relationship"*:	"represent exceptional or seldom invoked cases"
+ *"Describe the include relationship"*:	"represents that a use case uses the functionality of another use case."
+ *"Describe the generalization relationship"*:	"represents that one use case (child) inherits the structure, behavior, and relationships of another use case (parent)."
+ *"What is a Class Diagram?"*:	"A diagram that describes the structure of the system. Consists of classes that are abstractions which specify the common structure and behavior of a set of objects."
+ *"When are Class Diagrams used?"*:	"During requirements analysis, system design and object design."
+ *"What is an Aggregation?"*:	"A "consists of" relationship between two classes in a class diagram where the child class can exist independently of the parent class."
+ *"What is a Composition?"*	"A form of aggregation where the child class can not exist independently of the parent class."
+ *"What is an Inheritance/Generalization relationship?"*:	"An "is–a" relationship where the child class is a specific type of the parent class. The child class inherits the attributes and operations of the parent class."
+ *"What is an Interaction Diagram?"*:	"A diagram that represent the interactions that take place among objects in a system."
+ *"There are two types of interaction diagrams, Sequence and Communication diagrams. When are Sequence diagrams used?"*:	"During requirements analysis and system design"
+ *"What is a State Machine Diagram?"*:	"A diagram that models the behaviour of a single object, specifying the sequence of events that an object goes through during its lifetime in response to events."
+ *"What is an Activity Diagram?"*:	"A diagram that describes the behavior of a system in terms of activities. Activities are elements that represent the execution of a set of operations."
+ *"What are Component and Deployment Diagrams? "*:	"Models that describe the physical implementation of the system"
+ *"What is a Component Diagram?"*:	"A diagram that shows the structure of components, including their interface and implementation dependencies"
+ *"What is a Deployment Diagram?"*:	"A diagram that  shows how the components are deployed in hardware"
+ *"What is a Package Diagram?"*:	"A diagram that decompose a complex system into subsystems, where each subsystem is modeled as a package."
+ *"What is a package?"*:	"A package is a collection of logically related UML elements."
+ *"What is a Requirement?"*:	"A feature that the system must have or a constraint that it must satisfy to be accepted by the client."
+ *"Requirements engineering consists of two activities:"*:	"Requirements Elicitation and Requirements Analysis"
+ *"What is the difference between a Requirements Elicitation and a Requirements Analysis? "*:	"The requirements elicitation is a specification of the system in terms understood by the client while the analysis is a a specification of the system in terms understood by the developers."
+ *"What is the difference between a scenario and a use case?"*:	"Scenarios are concrete examples illustrating a single case, use cases are abstractions describing all possible cases."
+ *"What are functional requirements?"*:	"Requirements that describe what the system must/should do."
+ *"What are Non–functional requirements?"*:	"Requirements that describe aspects of the system that are not directly related to the functional behavior of the system. Such as performance and reliability."
+ *"What does the requirement validation criteria Correctness mean?"*:	"The requirements should represent the client’s view"
+ *"What does the requirement validation criteria Completeness mean?"*:	"All possible scenarios, in which the system can be used, should be described, including exceptional behavior by the user or the system."
+ *"What does the requirement validation criteria  Consistency mean?"*:	"There should not be any functional or nonfunctional requirements that contradict each other."
+ *"What does the requirement validation criteria   Unambiguity mean?"*:	"A requirement cannot be interpreted in mutually exclusive ways"
+ *"What does the requirement validation criteria Realism mean?"*	"The system can be implemented within constraints"
+ *"What does the requirement validation criteria Verifiability mean?"*	"It should be possible to design repeatable tests to demonstrate that the requirement works."
+ *"What does the requirement validation criteria Traceability mean?"*	"You should be able to trace each requirement throughout the software development"
+ *"What is an As–is scenario?"*:	"A scenario that describes the workflow of a current system."
+ *"What is a Visionary scenario?"*:	"A scenario that describes a future system."
+ *"What is an Evaluation scenario?"*:	"A scenario that describes user tasks against which the system is to be evaluated"
+ *"What is a Training scenario?"*:	"A tutorial used for introducing new users to the system."
+ *"The Requirements Analysis focuses on:"*:	"producing a model of the system which is correct, complete, consistent and verifiable."
+ *"What are Entity Objects?"*:	"Entity objects represent the persistent information tracked by the system."
+ *"What are Boundary Objects?"*:	"Boundary objects represent the interactions between the actors and the system"
+ *"What are Control Objects?"*:	"Control Objects mediate between boundaries and entities."
+ *"A model is correct if:"*:	"it represents the client’s view of the system"
+ *"A model is complete if:"*:	"every scenario through the system, including exceptions, is described"
+ *"A model is consistent if:"*:	"the model does not have any components that contradict each other"
+ *"A model is unambiguous if:"*:	"the model describes one system (one reality), not many"
+ *"A model is realistic if:"*:	"it can be implemented"
+ *"What is done during System Design?"*:	"Developers define the design goals, decompose the system into smaller subsystems and selects strategies for building the system (such as hardware/software strategy, handling of boundary conditions etc.)"
+ *"What is the result of System Design?"*:	"A model that includes a subsystem decomposition and a clear description of strategies for building the system."
+ *"What is Coupling?"*:	"The number of dependencies between two subsystems."
+ *"What is low coupling?"*:	"A change in one subsystem does not affect any other subsystem"
+ *"What is high coupling?"*:	"Changes to one subsystem will have a high impact on the other subsystems."
+ *"Why is it preferable to have as minimum coupling as possible?"*:	"Because it minimizes the impact that errors or future changes in one subsystem have on other subsystems."
+ *"When is high coupling an issue?"*:	"When it is likely that any subsystem changes."
+ *"When should we avoid decreasing the coupling?"*:	"When it is not likely that any subsystem changes and reducing coupling results in additional complexity."
+ *"What is Cohesion?"*:	"The number of dependencies within a subsystem."
+ *"What is high cohesion?"*:	"The classes in the subsystem perform similar tasks and are related to each other (via associations)"
+ *"What is low cohesion?"*:	"The subsystem contains a number of unrelated objects"
+ *"What is layering?"*:	"An approach to deal with complexity. Subsystems are organized in layers."
+ *"How are layers ordered?"*:	"Each layer can depend only on lower level layers and has no knowledge of the layers above it"
+ *"What is the difference between a closed architecture and an open architecture in layering?"*:	"In a closed architecture, each layer can access only the layer immediately below it while in an open architecture, a layer can also access layers at deeper levels."
+ *"What is partitioning?"*:	"An approach to deal with complexity. The system is divided into several independent (or weakly–coupled) subsystems that provide services on the same level of abstraction"
+ *"Explain the Repository Architectural style"*:	"Subsystems access and modify a single data structure called the central repository.  Subsystestems are relatively independent and interact only through the repository"
+ *"Explain the Client/Server Architectural style"*:	"A subsystem, the server, provides services to instances of other subsystems called the clients, which are responsible for interacting with the user."
+ *"Explain thePeer–to–Peer Architectural style"*:	"subsystems can act both as client or as serversm in the sense that each subsystem can request and provide services."
+ *"Explain the Model/View/Controller Architectural style"*:	"subsystems areclassified into three different types: model subsystems maintain domain knowledge, viewsubsystems display it to the user, and controller subsystems manage the sequence ofinteractions with the user."
+ *"What questions does the Hardware/Software Mapping address?"*:	"How shall we realize the subsystems: Hardware or Software? How is the object model mapped on the chosen hardware & software?"
+ *"What are UML Component and Deployment Diagrams?"*:	"Models for physical implementation of the system.  They show system components, their structure and dependencies and how they are deployed on computer nodes"
+ *"Explain component diagrams"*:	"Diagrams that show the structure of components, including their interface and implementation dependencies"
+ *"Explain deployment diagrams "*:	"Diagrams that show the runtime deployment of the system on computer nodes"
+ *"What questions does Data Management address?"*:	"Which data should be persistent?Where should persistent data be stored?How are they accessed?"
+ *"When should flat files be used as a storage management strategy?"*:	"When you have voluminous data (e.g. images),temporary data (e.g. core file) or low information density (e.g. archival files, history logs)"
+ *"Pros and cons of flat files:"*	"Pros: Cheap, simple permanent storage. Cons: require the application to take care of many issues, such as concurrent access and loss of data in case of system crash."
+ *"When should a Relational database or an object–oriented database be used as a storage management strategy?"*:	"when you need concurrent accesses and when you have multiple platforms or applications for the same data"
+ *"When should you choose a relational database?"*:	"When you have a large data sets"
+ *"When should you choose an object–oriented database?*:  "When you have extensive use of associations to retrieve data and medium–sized data set"
+ *"Explain Functional Decomposition."*:	"Divides the product/system based on functions, if a system has three functions it could be decomposed into three simpler prototypes."
+ *"What are som advantages of Functional Decomposition?"*:	"Can be used to define the tasks, Good in high–risk projects where changes are released incrementally, Easy to test a system designed with functional decomposition"
+ *"What are som disadvantages with Functional Decomposition?"*:	"If functions are not properly broken down, it can lead to a unnecessarily complex model and it will be difficult to understand the entire structure"
+ *"Explain Object–oriented decomposition."*:	"Divides the project/system based on its components."
+ *"What are some advantages of Object–oriented decomposition?"*	"Good transition from real world to model,  easier to divide the work and spend time on different parts independently, reduces complexity"
+ *"Explain Subsystem Decomposition"*:	"Divides a complex system into simpler parts, called subsystems."
+ *"What are some advantages of Subsystem Decomposition?"*:	"By decomposing the system into relatively independent subsystems, concurrent teams can work on individual subsystems with minimal communication overhead,  It reduces the complexity of the solution domain, in other words it helps designers and others understand what they're doing, It allows subsystems to be replaced or modified without affecting other subsystems."
+ *"What are some disadvantagesof Subsystem Decomposition?"*:	"It can be difficult to identify the correct number of subsystems. If we identify too many, it can increase cohesion and complexity,  when trying to achieve low coupling in the subsystem decomposition, it can result in additional complexity."
+ *"What is the purpose of modeling?"*:	"To reduce complexity by building a simplified representation of a reality which ignores irrelevant details."
+ *"List two advantages of using a programming language as sole (the only) notation throughout the software development process."*:	"1. Developers need only learn one notation for all development activities 2. Traceability among models and between models and code is made easier since they are written in the same notation"
+ *"List two disadvantages of using a programming language as sole (the only) notation throughout the software development process."*:	"1. A programming language is a low–level notation which is difficult to use for representing, for example, user requirements. 2. A programming language enables and encourages developers to represent implementation details too early."
+ *"Specify if the following decision were made during requirements or system design:  "The ticket distributor is composed of a user interface subsystem, a subsystem for computing tariff, and a network subsystem managing communication with the central computer.""*:	"This decision were made during the system design since it is an explanation of the subsystem decomposition. Subsystem decomposition is done during system design."
+ *"Specify if the following decision were made during requirements or system design:  “The ticket distributor provides the traveler with an on–line help”"*:	"This decision were made during requirements design since it is a non–functional requirement. Non–functional requirements are identified during requirements elicitation."
+ *"Specify if the following decision were made during requirements or system design:  “The ticket distributor will use PowerPC processor chips”"*:	"This decision were made during requirements design since it is a non–functional requirement. Non–functional requirements are identified during requirements elicitation."
+ *"Specify if the requirement “The system must be usable.” is verifiable or not."*:	"Not verifiable because we can not test this requirement since there is no precise definition of “usable”"
+ *"Specify if the requirement“The system must provide visual feedback to the user within 1 second of issuing a command.” is verifiable or not."*:	"Verifiable because we can test that his requirement works."
+ *"Specify if the requirement “The availability of the system must be above 95%.” is verifiable or not."*:	"Verifiable because we can test this assuming we have sufficient resources."
+ *"Specify if the requirement “The user interface of the new system should be similar enough to the old system such that users familiar with the old system can be easily trained to use the new system.” is verifiable or not."*:	"Not verifiable because we can not test this requirements since there is no precise definition of “easily trained”"
+ *"When should we use sequence diagrams?"*:	"When we want to identify the temporal relationship between objects over time and the sequence of operations as a response to one or more events."
+ *"When should we use  state chart diagrams?"*:	"When we want to identify changes to an individual object over time."
+ *"What is the difference between fork and stair structure of UML Sequence diagram?"*:	"In a fork structure, much of the dynamic behavior is placed in a single object while in a stair structure, each object delegates some responsibility to other objects."
+ *"When is a fork diagram more suitable than a stair diagram?"*:	"When the system is rapidly changing because a centralized structure has better support of change since all control is in one object."
+ *"What are some advantages of an open layered architecture?"*:	"The services of lower levels can be accessed directly, without the need of going through other layers on the way."
+ *"What are some disadvantages of an open layered architecture?"*:	"Open Layer Architectures are more difficult to maintain because each layer may communicate with all lower layers, hence increasing the degree of coupling in the architecture. A change to one layer may affect many other layers."
+ *"What are some advantages of aClosed Layered Architecture?"*	"Closed Layered Architectures lead to low coupling and subsystems can be integrated and tested incrementally."
+ *"What are some disadvantages of a Closed Layered Architecture?"*:	"For every layer added in a Closed Layer Architecture, there is a greater needed amount of storage and the time needed to go through all the layers will increase; this will increase the overhead and make it more difficult to meet nonfunctional requirements. Adding functionality to the system in later revisions can be difficult, especially when the additions are not expected."
+ *"What is delegation?"*:	"One object sends a request to another to perform a function and then gets the result back."
+ *"What are some pros of delegation?"*:	"Flexibility, any object can be replaced at run time by another one, it is possible to decide exactly which functions of the parent are accessible from the child (it is possible to omit functions we do not want)"
+ *"What are some cons of delegation?"*:	"less efficient than inheritance because we have indirect code (we need to send messages between objects)."
+ *"What are some pros of inheritance?"*:	"It is straightforward to use, easy to implement new functionality"
+ *"What are some cons of inheritance?"*:	"The child will inherit all the functions of the parent, even those that we might not want, it exposes the details of its parent class to a subclass, any change in the parent class implementation forces the subclass to change which requires recompilation of both."
+ *"What is the Observer pattern?"*:	"The Observer Pattern defines a one–to–many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."
+ *"When is an observer pattern applicable?"*:	"When a change to one object requires changing others and you don’t know how many objects need to be changed,  when an object should be able to notify other objects without making assumptions about who these objects are."
+ *"Give an example of when observer pattern is used."*:	"Social media – when a user updates their status, all their followers get a notification."
+ *"Explain the meaning of invariant"*:	"A predicate that is always true for all instances of a class. Ex: The number of players in a game should be positive."
+ *"Explain the meaning of pre–condition"*:	"A predicate that must be true before an operation is invoked.Preconditions are used to specify constraints that a class user must meet before calling the operation. Ex: The maximum number of players in the game has not yet been reached."
+ *"Explain the meaning of post–condition"*:	"A predicate that must be true after an operation is invoked. Ex: When a new player joins, the number of players must be exactly one more than the number of players before."
+ *"What is Blackbox testing?"*:	"Blackbox tests focus on the input/output behavior of a component without considering its implementation. Blackbox testing are used to test the functionality of the component."
+ *"What is Whitebox  testing?"*:	"Whitebox tests focus on the internal structure of a component.  A whitebox test makes sure that, independently from the particular input/output behavior, every state in the dynamic model of the object and every interaction among the objects is tested. Whitebox testing is used to test structural and dynamic aspects of the component."
+ *"What are some pros of Blackbox testing?"*:	"Less time consuming than whitebox testing, Well suited and efficient for large code segments,  Automated test cases do not need to be changed if the codebase is rapidly changing."
+ *"What are some cons of Blackbox testing?"*:	"It is less exhaustive than whitebox testing"
+ *"What are some pros of Whitebox  testing?"*:	"Whitebox tests are a more complete test of the system."
+ *"What are some cons of  Whitebox testing?"*:	"More time consuming than blackbox testing,Automated test cases can become useless if the codebase is rapidly changing."
+ *"What is Application domain?"*:	"Includes concepts that software developers are not familiar with"
+ *"What is Solution domain?"*:	"Provides developers with many competing implementation technologies."
+ *"What are the inputs of the System Analysis activity?"*:	"Inputs: A set of nonfunctional requirements and constraints and a use case model"
+ *"What are the outputs of the System Analysis activity?"*:	"Adynamic model which focuses on the behavior of the system, using sequence diagrams and state machines and ananalysis object model which focuses on the individual concepts that are manipulated by the system, using UML class diagrams."
+ *"Which approaches to class identification do you know?"*:	"Application domain approach, Syntactic approach, Common class pattern approach, Design patterns approach, Component–based approach"
+ *"Explain the Application domain approach"*:	"Developers ask an application domain expert to identify relevant abstractions"
+ *"Explain the Syntactic approach"*:	"Use noun–verb analysis (Abbot’s technique) to identify components of the object model (from descriptions or from use case cases – extract participating objects from flow of events)"
+ *"Explain the Common class pattern approach"*:	"Use generic classification theory of objects"
+ *"Explain the Design patterns approach"*:	"Use reusable design patterns"
+ *"Explain the Component–based approach"*:	"identify existing solution classes"
+ *"Decomposing a system into subsystems reduces the complexity developers have to deal with by simplifying the parts and increasing their cohesion. If cohesion is the guiding principle driving developers to decompose a system into small parts, which competing principle drives them to keep the total number of parts small?"*:	"We do not want to have too many subsystems because it can increase the complexity since it may introduce unnecessary development time and processing time."
+ *"What are Boundary Conditions?"*:	"Boundary conditions describe how the system is initialized and shut down as well as how exceptional cases are handled."
+ *"Why are use cases that describe boundary conditions described during system design? Who is/are the actors?"*:	"Because all subsystems have to be identified and the developers have to have decided on the order in which individual components are started and shutdown before the boundary conditions can be described. The actors in these use cases are those who starts and shutdowns the system."
+ *"Explain the difference between usage of inheritance during System Analysis and Object Design activities."*:	"During analysis, we use inheritance to classify objects into taxonomies.During Object Design, we use inheritance to identify interfaces and type hierarchies."
+ *"Explain the Specify Visibility activity."*:	"During this activity, we decide which operations are available to other objects and subsystems, and which are used only within a subsystem."
+ *"Which types of visibility are used during object design?"*:	"Private attribute, private operation, protected attribute, protected operation, public attribute, public operation, package"
+ *"Explain the visibility type private attribute"*:	"A private attribute can be accessed only by the class in which it is defined"
+ *"Explain the visibility type private operation"*:	"A private operation can be invoked only by the class in which it is defined."
+ *"Explain the visibility type protected attribute/protected operation"*:	"A Protected attribute/operation can be accessed by the class in which it is defined and by any descendant of that class (but not by any other class)"
+ *"Explain the visibility type public attribute/operation"*:	"A public attribute or operation can be accessed by any class"
+ *"Explain the visibility type package"*:	"An attribute or operation with visibility package can be accessed by any class in the nearest enclosing package (for example inside a subsystem)"
+ *"Explain why we have different visibility?"*:	"To specify which operations are available to other object and subsystems, and which are used only within a subsystem"
+ *"What is unit testing?"*:	"Unit testing tries to find faults in participating objects and/or subsystems with respect to the use cases from the use case model."
+ *"Which types of unit testing you know?"*:	"Path testing and equivalence testing"
+ *"What is path testing?"*:	"Identifies faults in the implementation of the component. The assumption behind path testing is that, by exercising all possible paths through the code at least once, most faults will trigger failures."
+ *"What is equivalence testing?"*:	"We can group similar classes/objects together into equivalence classes and then create a single test case for the entire equivalence class, instead of separate test cases for each of the individual classes/objects."
+ *"What is the meaning of Spike in eXtreme Programming?"*:	"A spike is a product development method originating from Extreme Programming that uses the simplest possible program to explore potential solutions."
